def solution(n, tops): 
    #큰삼각형에서 나올 수 있는 경우의수는 4개
    #큰삼각형을 이어 붙이면 나올 수 있는 경우의 수는 
    #큰삼각형이 없는 경우의 수는 n = 2일때, 8개 n=1일때, 3개 n = 3일때, n=2일때랑 2곱하고 1개는     #일부만 곱하면됨 16 + 6 == 22 꼭대기는 꼭대기 마름모를 넣을 수 있냐없냐이므로 
    #15개 x  n= 10일때, 17711 -> 점화식꼴
    # 역삼각형이 있냐 없냐에따라서 개수가 나뉨
    # 현재의 값이 이전의 값에 영향을 받으므로
    # k번째 아래 방향 정삼각형 위에 정삼각형이 붙은 경우 a[k] = a[k-1] + b[k-1]
    # b[k] = 2 × a[k-1] + 3 × b[k-1]
    # k번째 아래 방향 정삼각형 위에 정삼각형이 붙지 않은 경우 (tops[k-1] = 0) 
    # a[k] = a[k-1] + b[k-1] / b[k] = 2 × a[k-1] + 3 × b[k-1]
    MOD = 10007
    
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    print(a)
    
    a[1] = 1
    b[1] = 3 if tops[0] == 1 else 2
    
    for k in range(2, n + 1):
        a[k] = (a[k - 1] + b[k - 1]) % MOD
        b[k] = (2 * a[k - 1] + 3 * b[k - 1]) % MOD if tops[k - 1] == 1 else (a[k - 1] + 2 * b[k - 1]) % MOD
    print(a)
    print(b)
    result = (a[n] + b[n]) % MOD
    return result

"""
위쪽 정삼각형과 함께 마름모 타일로 덮기
왼쪽 정삼각형과 함께 마름모 타일로 덮기
오른쪽 정삼각형과 함께 마름모 타일로 덮기
정삼각형 타일로 덮기

가장 최근 아래 방향 정삼각형에 적용한 방법이 3번 방법인지의 여부가 다음 아래 방향 정삼각형을 덮는 방법에 영향을 미칩니다. 따라서 아래와 같이 두 개의 배열을 정의해야 합니다.

a[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우의 수
b[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우의 수

이제, a[k]와 b[k]를 a[k-1]과 b[k-1]에 대한 점화식으로 표현해 봅시다.

Case 1. `k`번째 아래 방향 정삼각형 위에 정삼각형이 붙은 경우 (tops[k-1] = 1)
a[k]의 경우, k-1번째 아래 방향 정삼각형을 덮은 방법이 3번 방법인지와 관계없이 3번 방법을 적용할 수 있습니다. 따라서, a[k] = a[k-1] + b[k-1]입니다.

b[k]의 경우, 만약 k-1번째 아래 방향 정삼각형을 덮은 방법이 3번 방법이었다면, k번째 아래 방향 정삼각형에는 1번 또는 4번 방법을 적용할 수 있습니다. 그렇지 않다면 1번, 2번, 4번 중 하나의 방법을 적용할 수 있습니다. 따라서, k-1번째 아래 방향 정삼각형을 3번 방법으로 덮는 a[k-1]개의 방법 각각마다 2개씩, 그리고 k-1번째 아래 방향 정삼각형을 3번 방법이 아닌 방법으로 덮는 b[k-1]개의 방법 각각마다 3개씩의 방법이 있습니다. 따라서 b[k] = 2 × a[k-1] + 3 × b[k-1]입니다.

Case 2. `k`번째 아래 방향 정삼각형 위에 정삼각형이 붙지 않은 경우 (tops[k-1] = 0)
a[k]의 경우 Case 1과 동일하게 a[k] = a[k-1] + b[k-1]입니다.

b[k]의 경우, 1번 방법을 적용할 수 없습니다. 따라서, k-1번째 아래 방향 정삼각형을 3번 방법으로 덮는 a[k-1]개의 방법 각각마다 1개씩, 그리고 k-1번째 아래 방향 정삼각형을 3번 방법이 아닌 방법으로 덮는 b[k-1]개의 방법 각각마다 2개씩의 방법이 있습니다. 따라서, b[k] = a[k-1] + 2 x b[k-1]입니다.



이와 같이 a[k]와 b[k]를 a[k-1]과 b[k-1]에 대한 식으로 나타낼 수 있으므로, 다이나믹 프로그래밍을 이용하여 a[n]과 b[n]을 구할 수 있습니다. 초기값은 a[1]=1, b[1]은 1번째 정삼각형 위에 정삼각형이 붙은 경우 3, 그렇지 않은 경우 2로 초기화하거나, a[0] = 0, b[0] = 1로 초기화하는 방법이 있습니다.

구하려는 정답은 a[n] + b[n]입니다. 경우의 수를 10007로 나눈 나머지를 구해야 하므로, 연산을 할 때마다 10007로 나눈 나머지를 구하여 저장하면 됩니다. 예를 들어, a[k] = (a[k-1] + b[k-1]) % 10007와 같이 계산하면 됩니다.이때, 전체 시간복잡도는 O(n)입니다.


"""